# December 8, 2025 — Hex Grid with Networked Cursor Highlighting

This entry documents how we reached the milestone of rendering an interactive hex grid with synchronized cursor highlights across the network. It is written as an instructional walkthrough so future contributors can reproduce the flow, understand the design trade-offs, and iterate safely.

## What we shipped

- A procedurally generated hex field with color-coded cells sized for multiplayer demos.
- Local hover detection that outlines and softly glows the selected hex.
- Network propagation of cursor positions so every peer sees everyone else’s highlights in real time.
- Demo harness that simulates remote cursors to validate performance and visual clarity without multiple humans connected.
- Logging hooks to observe cursor traffic alongside player join/leave events.

## Files to know

- `hex_field.gd`: Owns the grid, hover detection, and all highlight visuals (local and remote).
- `addons/netcode/cursor_sync.gd`: Periodically reads the hovered hex, sends updates, and emits remote cursor signals.
- `addons/netcode/cursor_simulator.gd`: Generates deterministic cursor paths for demo clients.
- `addons/netcode/network_manager.gd`: Moves cursor updates between peers, keeps per-player hover state.
- `addons/netcode/demo_launcher.gd`: Spins up server/clients locally for the demo flow (see “Try it yourself”).

## Architecture at a glance

1. **Hex grid source of truth**: `hex_field.gd` extends `HexagonTileMapLayer`, generating cells via `cube_range` with a fixed radius. Each tile is colored by `posmod(cube.x - cube.y, 3)` for easy visual separation.
2. **Local hover sensing**: In normal mode, `_process` reads `get_local_mouse_position` → `get_closest_cell_from_local` and validates the cell exists. In demo mode, it trusts `local_player.hovered_hex` instead (populated by the simulator).
3. **Local highlight rendering**: `_update_local_highlight` draws a `Line2D` outline plus a translucent `Polygon2D` glow. Colors are pulled from the local player’s palette so changing color indexes immediately updates the highlight.
4. **Network sync loop**: `cursor_sync.gd` sends cursor updates every `sync_rate` seconds when networked. It only transmits when the hovered hex changes, and it uses an unreliable send for low-latency cursor traffic.
5. **Remote application**: Incoming cursor updates in `network_manager.gd` set `player.hovered_hex`. `cursor_sync.gd` emits `remote_cursor_updated`, and `hex_field.gd` renders a dedicated outline/glow per remote player with their assigned color.
6. **Demo automation**: `cursor_simulator.gd` produces patterned hover positions (spiral, random walk, circle, figure-eight) to stress-test syncing and visual overlap without manual input.

## Step-by-step: How the pieces fit

### 1) Building the hex field

`hex_field.gd` is both the map and the rendering surface. `generate_field()` clears the tilemap and lays down coordinates within `FIELD_RADIUS = 20`. The atlas source (`SOURCE_ID`) and tile UV (`ATLAS_COORDS`) point at the green tileset used in the demo. Because the grid is deterministic, clients and server share identical coordinates without syncing terrain state.

**Why cube coordinates?** Hex grids are easier to reason about in 3D “cube” space (x + y + z = 0). Distance is Manhattan/2, neighbors are six fixed vectors, and axial conversions stay consistent. We keep everything in cube space for math (range, outlines, neighbors) and only convert to map indices when talking to Godot’s tilemap. That keeps highlighting, path checks, and networking aligned on a single, lossless coordinate system.

### 2) Tracking local hover

During `_process`, we choose between two inputs:

- **Normal mode**: Mouse → `get_closest_cell_from_local` → cube coords → validated against `get_cell_source_id`.
- **Demo mode**: `local_player.hovered_hex` already populated by the simulator; server intentionally sets `INVALID_HEX` because it has no cursor.

If the hovered hex changes, `_update_local_highlight` redraws the outline/glow. Clearing happens when hovering off-map or over empty space. This keeps visuals responsive while avoiding stale highlights.

### 3) Drawing the highlight

- Outline: `Line2D`, closed loop, z-index above tiles, width `OUTLINE_WIDTH`.
- Glow: `Polygon2D` with alpha `GLOW_ALPHA`, z-index below the outline.
- Colors: Pulled from `PlayerState.PLAYER_COLORS` so every player has a stable hue; the local color is refreshed on each update to respect runtime palette changes.

The visuals are recreated per update rather than cached polygons because hex outlines are cheap to recompute and it keeps the API simple.

### 4) Emitting cursor updates

`cursor_sync.gd` runs a lightweight timer in `_process`. When the timer crosses `sync_rate` (20 fps by default), it:

- Computes the hovered hex via `_get_hovered_hex` (respecting demo vs. normal mode).
- Bails if there is no `NetworkManager` or no `local_player`.
- Compares to `_last_sent_hex` to avoid redundant packets.
- Sends `MessageType.CURSOR_UPDATE` with `{ "hex": [x, y, z] }`, or `{ "hex": null }` when invalid.
- Writes the hovered hex back into `local_player.hovered_hex` to keep local state consistent.

Cursor updates are flagged as unreliable traffic to favor low latency over delivery guarantees; the next tick will refresh if a packet drops.

### 5) Receiving and rendering remotes

`network_manager.gd`’s `_handle_cursor_update` writes `hovered_hex` onto the corresponding `PlayerState`. `cursor_sync.gd` then iterates remote players every frame and emits `remote_cursor_updated` with each player’s current hex. `hex_field.gd` listens and either hides or draws the remote outline/glow:

- Each remote gets its own `Line2D` + `Polygon2D`, stored in `_remote_highlights`.
- Invalid or off-map hexes hide the visuals to prevent ghost highlights.
- Colors are chosen per player ID modulo the palette for stability.

When a player disconnects, `remote_cursor_removed` triggers cleanup (`queue_free` on outline/glow) to avoid leaks.

### 6) Demo harness

`cursor_simulator.gd` attaches to clients (not the server) in demo mode. It selects patterns based on client index:

- Client 1: Spiral on the left, slightly faster.
- Client 2: Random walk on the right, with bounds enforced by `_hex_distance` and `_hex_toward`.

Each tick, it advances the pattern, writes the target hex to `local_player.hovered_hex`, and broadcasts a cursor update. This validates render + network flow without manual input or multiple human testers.

### 7) Logging and observability

`NetworkLogger` (if present) records cursor updates and player events. `cursor_sync.gd` calls `_log_cursor_update` for both local and remote cursors when they are active, making it easy to correlate visual glitches with network traffic in logs.

## Try it yourself (demo flow)

1. Ensure you have Nix/direnv set up (`direnv allow`) so Godot and deps are available.
2. Run the demo launcher scene that spins up a server and two clients:
   - Server: orchestrates but does not render a cursor.
   - Clients: each runs `cursor_simulator.gd` and shows both local and remote highlights.
3. Observe:
   - Hex field renders with alternating colors.
   - Each client shows its own outline/glow plus the other client’s outline/glow in distinct colors.
   - Highlights disappear when cursors leave the field.
4. Toggle demo/normal modes in `DemoLauncher` to switch between simulated cursors and real mouse hover.

If you are running a manual multiplayer session instead of the demo harness, start the server, connect clients, and move the mouse over the hex map. You should see remote highlights update in near-real time.

## Common pitfalls we solved

- **Stale highlights on disconnect**: Added `remote_cursor_removed` handling to free per-player nodes.
- **Ghost highlights on invalid tiles**: Validate `cube_to_map` → `get_cell_source_id` before drawing.
- **Color drift after palette changes**: Local highlight re-pulls the player color each update; remote highlights derive colors on creation using player ID modulo the palette.
- **Excess traffic**: Only send when the hovered hex changes; use unreliable sends for cursors to avoid queue buildup.
- **Server pretending to be a player**: In demo mode the server sets `INVALID_HEX` so it never draws a cursor.

## Extending this milestone

- **Per-player labels or avatars**: Add `Label` or `Sprite2D` siblings to the outline/glow per remote entry in `_remote_highlights`.
- **Click-to-act**: Reuse `_hovered_hex` to drive actions (e.g., select, move) once interaction rules are defined.
- **Rate adaptation**: Expose `sync_rate` via project settings and dynamically back off under load.
- **Interpolation**: For rapid cursor motion, interpolate between last-known hexes to smooth visuals on slower clients.
- **Spectator mode**: Allow a read-only client that only listens to cursor updates without owning a player state.

## Lessons learned

- Keep the grid deterministic to avoid syncing terrain—cursor updates stay lightweight.
- Treat cursors as unreliable, high-frequency signals; correctness is maintained by the next packet.
- Separate visuals (outlines/glows) per player to avoid allocation churn when states change.
- Demo automation is invaluable: the spiral + random walk patterns quickly expose visual overlap, invalid cells, or rate issues.
- Logging hooks make it much easier to debug cursor desync without stepping through frames.

## Next steps

- Add small latency/jitter simulation in the demo to observe behavior under packet loss.
- Experiment with thicker outlines for colorblind accessibility and per-player shape variations.
- Document Godot editor steps to drop `CursorSync` and `HexField` into new scenes quickly.

## How to reuse in new scenes

1. Drop a `HexagonTileMapLayer` with `hex_field.gd` attached.
2. Add `CursorSync` as a sibling or parent; leave `hex_field` export null to auto-find.
3. Wire `remote_cursor_updated` and `remote_cursor_removed` if you need custom reactions; otherwise, the defaults just draw highlights.
4. Include `NetworkManager` and hook it to your transport. Ensure `PlayerState` creation sets a color index and initializes `hovered_hex`.
5. For demos, add `CursorSimulator` to the scene tree and ensure `DemoLauncher` toggles `is_demo_mode` appropriately.

## Layered roles and cards

- Two advisor views: diamonds = resources (industry), hearts = desirability (urbanist); spades mark hazards on either layer.
- Cards rank 2–10, J, K, Q, A with the ordering Q > K > J.
- Advisors see only their layer’s perimeter tiles; the mayor sees advisor nominations and their own hand.
- Turn loop: draw 3 mayor cards (reveal one), advisors nominate adjacent tiles, mayor places a card on a nominated hex. Spade placement ends the game immediately.
- Scoring: mayor gets 1 per best-guess placement (chosen hex is optimal vs. real layer among nominations for the played suit). Advisors get 1 when the mayor builds on their nomination.

## Timeline recap

- **Field generation**: Locked in `FIELD_RADIUS` and color striping for clarity.
- **Local hover + visuals**: Added outline/glow pairing and invalidation checks.
- **Network sync**: Implemented `cursor_sync.gd` timer loop, message type, and state write-back.
- **Remote rendering**: Per-player nodes with proper cleanup and color assignment.
- **Demo + logging**: Patterned cursor simulator plus logger hooks to validate end-to-end.

## Closing

We now have a robust, composable foundation for multiplayer hex interactions: a deterministic grid, efficient cursor sync, and clear visuals for both local and remote players. The current milestone proves the path; upcoming work can safely layer actions, accessibility tweaks, and richer avatar cues on top of this solid base.

